<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>月飼い - Keeping the Moon</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }
    #container { width: 100%; height: 100%; }
    canvas { display: block; }
    #title {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.5em;
      pointer-events: none;
      z-index: 100;
      opacity: 1;
      transition: opacity 3s ease;
    }
    #title.hidden { opacity: 0; }
    #hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 0.2em;
      pointer-events: none;
      z-index: 100;
      opacity: 1;
      transition: opacity 2s ease;
    }
    #hint.hidden { opacity: 0; }
    #credits {
      position: fixed;
      bottom: 16px;
      right: 16px;
      font-family: "Yu Gothic", "Hiragino Kaku Gothic ProN", sans-serif;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      line-height: 1.6;
      text-align: right;
      pointer-events: none;
      z-index: 100;
      opacity: 1;
      transition: opacity 0.8s ease;
    }
    #credits.hidden { opacity: 0; }
    #credits a {
      color: rgba(255, 255, 255, 0.5);
      text-decoration: none;
      pointer-events: auto;
      transition: color 0.3s ease;
    }
    #credits a:hover {
      color: rgba(255, 255, 255, 0.8);
    }
    #credits-area {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 120px;
      height: 120px;
      z-index: 101;
    }
    #credits-area:hover ~ #credits,
    #credits-area:hover ~ #credits.hidden {
      opacity: 0.7;
      pointer-events: auto;
    }

    /* 月相スライダー（左下・ホバー表示） */
    #phase-area {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 150px;
      height: 130px;
      z-index: 101;
    }
    #phase-ui {
      position: fixed;
      bottom: 16px;
      left: 16px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      color: rgba(255, 255, 255, 0.65);
      font-family: "Yu Gothic", "Hiragino Kaku Gothic ProN", sans-serif;
      font-size: 11px;
      line-height: 1.6;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 100;
      width: 180px;
    }
    #phase-area:hover ~ #phase-ui,
    #phase-area:hover ~ #phase-ui.hidden {
      opacity: 0.9;
      pointer-events: auto;
    }
    #phase-ui label {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #phase-ui input[type="range"] {
      width: 120px;
    }
    #phase-ui .value {
      min-width: 48px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="title">月 飼 い</div>
  <div id="hint">水面に触れてみてください</div>
  <div id="credits-area"></div>
  <div id="credits">
    Moon texture: <a href="https://www.solarsystemscope.com/textures/" target="_blank" rel="noopener">Solar System Scope</a><br>
    Repository: <a href="https://github.com/clockcrockwork/moon-keeper" target="_blank" rel="noopener">moon-keeper</a>
  </div>
  <div id="phase-area"></div>
  <div id="phase-ui" class="hidden">
    <label>
      月相
      <input id="phase-slider" type="range" min="0" max="1" step="0.001" value="0.5" aria-label="moon phase" />
      <span class="value" id="phase-value">0.500</span>
    </label>
    <div>左下ホバーで表示（制作・検証用）</div>
  </div>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    // ========================================
    // 設定
    // ========================================
    const CONFIG = {
      moonDepth: 5,
      moonSize: 2.0,
      starCount: 300,
      starDensityMin: 0.35,
      starDensityMax: 1.0,
    };

    // ========================================
    // 月相計算
    // ========================================
    function illuminatedFraction(phase01) {
      // 0.0 = 新月, 0.5 = 満月
      return 0.5 * (1 - Math.cos(phase01 * Math.PI * 2));
    }

    function calculateMoonPhase(date = new Date()) {
      // 2000-01-06 18:14 UTC の新月を基準にする簡易モデル
      const synodicMonth = 29.53058867;
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14, 0);
      const daysSinceKnown = (date.getTime() - knownNewMoon) / 86400000;
      const phase01 = ((daysSinceKnown % synodicMonth) + synodicMonth) % synodicMonth / synodicMonth;
      return {
        phase01,
        fraction01: illuminatedFraction(phase01),
      };
    }

    const phaseState = calculateMoonPhase();
    
    // ========================================
    // レンダラー・カメラ
    // ========================================
    const container = document.getElementById('container');
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    // メインカメラ（上から見下ろす）
    const camera = new THREE.PerspectiveCamera(
      50, window.innerWidth / window.innerHeight, 0.1, 100
    );
    camera.position.set(0, 8, 0);
    camera.lookAt(0, 0, 0);
    
    // ========================================
    // シーン1: 月と星空（水中の世界）
    // ========================================
    const underwaterScene = new THREE.Scene();
    underwaterScene.background = new THREE.Color(0x010306); // より深い夜空色
    
    // 星空
    function createStarfield() {
      const geo = new THREE.BufferGeometry();
      const positions = [], sizes = [], alphas = [];
      
      for (let i = 0; i < CONFIG.starCount; i++) {
        const x = (Math.random() - 0.5) * 50;
        const z = (Math.random() - 0.5) * 50;
        const y = -20 - Math.random() * 15;
        positions.push(x, y, z);
        sizes.push(0.4 + Math.random() * 0.8);
        
        // 中心から離れるほど明るい（月明かりで中心は暗い）
        const dist = Math.sqrt(x*x + z*z);
        alphas.push(Math.min(1, dist / 12) * 0.5 + 0.1);
      }
      
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
      geo.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

      const mat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, density: { value: CONFIG.starDensityMax } },
        vertexShader: `
          attribute float size;
          attribute float alpha;
          varying float vAlpha;
          uniform float time;
          uniform float density;
          void main() {
            float twinkle = sin(time * 0.4 + position.x * 1.5 + position.z) * 0.2 + 0.8;
            vAlpha = alpha * twinkle * density;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (120.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          void main() {
            float d = length(gl_PointCoord - 0.5);
            if (d > 0.5) discard;
            float glow = smoothstep(0.5, 0.0, d);
            gl_FragColor = vec4(0.75, 0.8, 1.0, glow * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      return new THREE.Points(geo, mat);
    }
    
    const starfield = createStarfield();
    underwaterScene.add(starfield);
    
    // 月
    function createMoon() {
      const geo = new THREE.SphereGeometry(CONFIG.moonSize, 64, 64);
      const loader = new THREE.TextureLoader();
      const tex = loader.load(
        'moon.webp',
        t => { t.colorSpace = THREE.SRGBColorSpace; }
      );
      const mat = new THREE.MeshStandardMaterial({
        map: tex,
        roughness: 0.8,
        metalness: 0.0,
        emissive: new THREE.Color(0x0d0d0d),
        emissiveIntensity: 0.25,
      });
      const mesh = new THREE.Mesh(geo, mat);
      return mesh;
    }

    const moon = createMoon();
    const moonInitialRotation = Math.random() * Math.PI * 2;

    const moonPivot = new THREE.Group();
    moonPivot.position.set(0, -CONFIG.moonDepth, 0);
    moon.position.set(0, 0, 0);
    moonPivot.add(moon);
    moonPivot.rotation.x = Math.PI / 2;
    moon.rotation.y = moonInitialRotation;
    underwaterScene.add(moonPivot);

    // 月の周りの淡いグロー（控えめに）
    const moonGlow = new THREE.Mesh(
      new THREE.PlaneGeometry(CONFIG.moonSize * 5, CONFIG.moonSize * 5),
      new THREE.ShaderMaterial({
        uniforms: { glowStrength: { value: 0.35 } },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform float glowStrength;
          void main() {
            float dist = length(vUv - 0.5) * 2.0;
            float glow = smoothstep(1.0, 0.3, dist) * glowStrength;
            gl_FragColor = vec4(0.9, 0.85, 0.7, glow);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      })
    );
    moonGlow.rotation.x = -Math.PI / 2;
    moonGlow.position.copy(moonPivot.position);
    underwaterScene.add(moonGlow);

    const ambient = new THREE.AmbientLight(0xffffff, 0.05);
    underwaterScene.add(ambient);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.4);
    const sunTarget = new THREE.Object3D();
    sunTarget.position.copy(moonPivot.position);
    underwaterScene.add(sunTarget);
    sunLight.target = sunTarget;
    sunLight.position.set(3, 4, 1);
    underwaterScene.add(sunLight);
    
    // ========================================
    // レンダーターゲット（月と星空をテクスチャに）
    // ========================================
    const renderTarget = new THREE.WebGLRenderTarget(
      window.innerWidth * renderer.getPixelRatio(),
      window.innerHeight * renderer.getPixelRatio()
    );
    
    // ========================================
    // シーン2: 水面（メインシーン）
    // ========================================
    const mainScene = new THREE.Scene();
    
    const WATER_SIZE = 16;
    const WATER_SEG = 150;
    const waveHeight = new Float32Array((WATER_SEG + 1) ** 2);
    const waveVelocity = new Float32Array((WATER_SEG + 1) ** 2);
    let touchEnergy = 0;
    
    function createWater() {
      const geo = new THREE.PlaneGeometry(WATER_SIZE, WATER_SIZE, WATER_SEG, WATER_SEG);
      geo.rotateX(-Math.PI / 2);
      
      const count = geo.attributes.position.count;
      geo.setAttribute('waveHeight', new THREE.BufferAttribute(new Float32Array(count), 1));
      
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          underwaterTex: { value: renderTarget.texture },
          resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          time: { value: 0 },
          moonPos: { value: new THREE.Vector3(0, -CONFIG.moonDepth, 0) },
          cameraY: { value: camera.position.y },
          phaseFraction: { value: phaseState.fraction01 },
          moonColor: { value: new THREE.Color(0.9, 0.85, 0.7) },
          touchEnergy: { value: 0 },
        },
        vertexShader: `
          attribute float waveHeight;
          varying float vHeight;
          varying vec2 vScreenUV;
          varying vec3 vWorldPos;
          varying vec3 vNormal;
          
          void main() {
            vHeight = waveHeight;
            
            vec3 pos = position;
            pos.y += waveHeight * 0.4;
            
            vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
            
            // 法線を波から計算
            // 隣接頂点との高低差から法線を推定（シンプル版）
            vNormal = normalize(vec3(-waveHeight * 0.5, 1.0, -waveHeight * 0.3));
            
            vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            vScreenUV = (clipPos.xy / clipPos.w) * 0.5 + 0.5;
            
            gl_Position = clipPos;
          }
        `,
        fragmentShader: `
          uniform sampler2D underwaterTex;
          uniform vec2 resolution;
          uniform float time;
          uniform vec3 moonPos;
          uniform float cameraY;
          uniform float phaseFraction;
          uniform vec3 moonColor;
          uniform float touchEnergy;
          
          varying float vHeight;
          varying vec2 vScreenUV;
          varying vec3 vWorldPos;
          varying vec3 vNormal;

          void main() {
            float fraction = clamp(phaseFraction, 0.0, 1.0);

            // 波による屈折オフセット（デカップリング済み）
            vec2 baseDistortion = vNormal.xz * vHeight * 0.35;
            float distortGain = mix(1.15, 1.0, pow(fraction, 0.8));
            vec2 distortion = baseDistortion * distortGain;
            vec2 uv = clamp(vScreenUV + distortion, 0.0, 1.0);

            // 水中の映像（月と星空）を歪めて取得
            vec3 underwater = texture2D(underwaterTex, uv).rgb;

            // 月明かりの反射（控えめなスペキュラ）
            vec3 viewDir = normalize(vec3(0.0, cameraY, 0.0) - vWorldPos);
            vec3 lightDir = normalize(moonPos - vWorldPos);
            vec3 halfDir = normalize(viewDir + lightDir);
            vec3 normal = normalize(vNormal);

            float spec = pow(max(dot(normal, halfDir), 0.0), 64.0);
            float specGain = mix(0.12, 0.25, pow(fraction, 0.8));
            vec3 moonlightReflect = moonColor * spec * specGain;

            // 波頭のハイライト（二段構え）
            float waveSignal = smoothstep(0.01, 0.06, vHeight);
            float waveBase = waveSignal * 0.35;
            float waveMoonAdd = waveSignal * 0.20 * pow(fraction, 0.7);
            float waveHighlight = waveBase + waveMoonAdd;
            vec3 highlight = vec3(0.7, 0.75, 0.9) * waveHighlight;

            // 触った瞬間だけ出る補助光
            float interaction = touchEnergy * smoothstep(0.02, 0.08, abs(vHeight));
            vec3 touchGlow = vec3(0.5, 0.6, 0.9) * interaction * 0.35;

            // 水面の色味（エッジ部分のみ、中心は透明）
            float distFromCenter = length(vWorldPos.xz);
            float edgeFade = smoothstep(3.0, 8.0, distFromCenter);
            vec3 waterTint = vec3(0.01, 0.03, 0.08) * edgeFade * 0.3;

            // 合成（水中の映像がメイン）
            vec3 finalColor = underwater;
            finalColor += waterTint;
            finalColor += moonlightReflect;
            finalColor += highlight;
            finalColor += touchGlow;

            // 波の谷は少し暗く
            float valleyDark = smoothstep(0.0, -0.08, vHeight) * 0.15;
            finalColor *= (1.0 - valleyDark);

            gl_FragColor = vec4(finalColor, 1.0);
          }
        `,
      });
      
      return new THREE.Mesh(geo, mat);
    }
    
    const water = createWater();
    mainScene.add(water);

    function updatePhaseUI() {
      const slider = document.getElementById('phase-slider');
      const value = document.getElementById('phase-value');
      if (slider && value) {
        slider.value = phaseState.phase01.toFixed(3);
        value.textContent = phaseState.phase01.toFixed(3);
      }
    }

    function applyPhaseState() {
      const angle = phaseState.phase01 * Math.PI * 2;
      const radius = 6.5;
      sunLight.position.set(Math.cos(angle) * radius, 4.5, Math.sin(angle) * radius);
      sunLight.target.position.copy(moonPivot.position);
      sunLight.target.updateMatrixWorld();

      const glow = THREE.MathUtils.lerp(0.2, 0.55, Math.pow(phaseState.fraction01, 0.7));
      moonGlow.material.uniforms.glowStrength.value = glow;
      sunLight.intensity = THREE.MathUtils.lerp(0.45, 1.6, Math.pow(phaseState.fraction01, 0.9));
      water.material.uniforms.phaseFraction.value = phaseState.fraction01;
      water.material.uniforms.moonPos.value.set(moonPivot.position.x, moonPivot.position.y, moonPivot.position.z);

      const density = THREE.MathUtils.lerp(
        CONFIG.starDensityMax,
        CONFIG.starDensityMin,
        Math.pow(phaseState.fraction01, 0.8)
      );
      starfield.material.uniforms.density.value = density;

      updatePhaseUI();
    }

    function initPhaseUI() {
      const slider = document.getElementById('phase-slider');
      if (!slider) return;
      slider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        phaseState.phase01 = isNaN(value) ? phaseState.phase01 : value;
        phaseState.fraction01 = illuminatedFraction(phaseState.phase01);
        applyPhaseState();
      });
      updatePhaseUI();
    }
    
    // ========================================
    // 波のシミュレーション
    // ========================================
    function updateWaves() {
      const seg = WATER_SEG + 1;
      const damping = 0.97;
      const speed = 0.45;
      
      // 波動方程式（内部）
      for (let j = 1; j < seg - 1; j++) {
        for (let i = 1; i < seg - 1; i++) {
          const idx = j * seg + i;
          const avg = (
            waveHeight[idx - 1] + waveHeight[idx + 1] +
            waveHeight[idx - seg] + waveHeight[idx + seg]
          ) * 0.25;
          
          waveVelocity[idx] += (avg - waveHeight[idx]) * speed;
          waveVelocity[idx] *= damping;
        }
      }
      
      // 境界反射（壁で跳ね返る）
      for (let i = 0; i < seg; i++) {
        // 上端・下端
        waveHeight[i] = waveHeight[i + seg];
        waveHeight[(seg - 1) * seg + i] = waveHeight[(seg - 2) * seg + i];
        // 左端・右端
        waveHeight[i * seg] = waveHeight[i * seg + 1];
        waveHeight[i * seg + seg - 1] = waveHeight[i * seg + seg - 2];
      }
      
      for (let i = 0; i < waveHeight.length; i++) {
        waveHeight[i] += waveVelocity[i];
        waveHeight[i] = Math.max(-0.8, Math.min(0.8, waveHeight[i]));
      }
      
      // ジオメトリ更新
      const attr = water.geometry.getAttribute('waveHeight');
      for (let i = 0; i < attr.count; i++) {
        attr.setX(i, waveHeight[i]);
      }
      attr.needsUpdate = true;
    }
    
    // 波紋を発生
    function createRipple(wx, wz, strength = 0.5) {
      const seg = WATER_SEG + 1;
      const half = WATER_SIZE / 2;
      const gx = Math.floor((wx + half) / WATER_SIZE * WATER_SEG);
      const gz = Math.floor((wz + half) / WATER_SIZE * WATER_SEG);

      touchEnergy = Math.min(1.0, touchEnergy + strength * 0.6);
      
      const radius = 4;
      for (let dz = -radius; dz <= radius; dz++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const x = gx + dx, z = gz + dz;
          if (x >= 0 && x < seg && z >= 0 && z < seg) {
            const dist = Math.sqrt(dx*dx + dz*dz);
            if (dist < radius) {
              const idx = z * seg + x;
              waveHeight[idx] = -(1 - dist / radius) * strength;
            }
          }
        }
      }
    }
    
    // ========================================
    // インタラクション
    // ========================================
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let isDown = false;
    
    function onDown(e) {
      isDown = true;
      handle(e);
      hideOverlay();
    }
    
    // オーバーレイを隠す
    let overlayHidden = false;
    function hideOverlay() {
      if (!overlayHidden) {
        document.getElementById('hint').classList.add('hidden');
        document.getElementById('title').classList.add('hidden');
        document.getElementById('credits').classList.add('hidden');
        overlayHidden = true;
      }
    }
    
    // 数秒後に自動フェードアウト
    setTimeout(() => {
      hideOverlay();
    }, 4000);
    function onMove(e) { if (isDown) handle(e); }
    function onUp() { isDown = false; }
    
    function handle(e) {
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = (cx / window.innerWidth) * 2 - 1;
      pointer.y = -(cy / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObject(water);
      if (hits.length > 0) {
        createRipple(hits[0].point.x, hits[0].point.z, 0.6);
      }
    }
    
    renderer.domElement.addEventListener('mousedown', onDown);
    renderer.domElement.addEventListener('mousemove', onMove);
    renderer.domElement.addEventListener('mouseup', onUp);
    renderer.domElement.addEventListener('mouseleave', onUp);
    renderer.domElement.addEventListener('touchstart', onDown, { passive: false });
    renderer.domElement.addEventListener('touchmove', onMove, { passive: false });
    renderer.domElement.addEventListener('touchend', onUp);

    initPhaseUI();
    applyPhaseState();
    
    // ========================================
    // リサイズ
    // ========================================
    function onResize() {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      renderTarget.setSize(w * renderer.getPixelRatio(), h * renderer.getPixelRatio());
      water.material.uniforms.resolution.value.set(w, h);
    }
    window.addEventListener('resize', onResize);
    
    // ========================================
    // アニメーション
    // ========================================
    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now() * 0.001;

      updateWaves();

      moon.rotation.y = moonInitialRotation + time * 0.006;
      moonGlow.position.copy(moonPivot.position);
      moonGlow.quaternion.copy(camera.quaternion);
      starfield.material.uniforms.time.value = time;
      water.material.uniforms.time.value = time;
      touchEnergy *= 0.92;
      water.material.uniforms.touchEnergy.value = touchEnergy;

      // 1) 月と星空をレンダーターゲットに描画
      renderer.setRenderTarget(renderTarget);
      renderer.render(underwaterScene, camera);
      
      // 2) 水面をメインに描画
      renderer.setRenderTarget(null);
      renderer.render(mainScene, camera);
    }
    
    animate();
    
    // 自然な波紋（少し強め）
    setInterval(() => {
      const x = (Math.random() - 0.5) * WATER_SIZE * 0.7;
      const z = (Math.random() - 0.5) * WATER_SIZE * 0.7;
      createRipple(x, z, 0.25);
    }, 2500);

  </script>
</body>
</html>
